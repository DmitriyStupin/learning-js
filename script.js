/*
  Функция - это, грубо говоря, блок кода, который будет повторяться, поэтому его можно вынести в отдельную
  сущность.
*/
/*
  Первый способ: Function Declaration
*/

// function logHello() {
//   console.log('Hello')
// }
// logHello()
// logHello()


/*
  Очень важная тема - Область видимости.
  Она бывает глобальной и локальной.
  Вот пример:
*/
// const message = 'Глобальный привет!'

// function logMessage() {
//   const message = 'Локальный привет!'

//   console.log(message)
// }

// logMessage()

// console.log(message)

/*
  У нас есть 2 переменные message. Казалось бы, должна быть ошибка, ведь двух переменныъ
  с одинаковым названием быть не может. Но тут как раз и работает область видимости.

  Переменная, которая создана на глобальном уровне - будет доступна всем функциям, циклам и тд.
  А локальная переменная в функции logMessage() - будет доступна только для этой самой функции.

  Если мы сделаем так, то у нас получится ошибка, ведь мы не можем "добраться" до локальной переменной message:
*/

// function logMessage() {
//   const message = 'Локальный привет!'

//   console.log(message)
// }

// logMessage()

// console.log(message)


/*
  В функцию при вызове можно передавать данные. Для этого нужно, в самом объявлении функции указать это.

  Сущности, которые мы указываем при объявлении функции - это ПАРАМЕТРЫ.
  А сущности, которые мы передаем при вызове функции - это АРГУМЕНТЫ.
*/

// function logHello(message, name) {
//   console.log(`${message}, ${name}`)
// }
// logHello('Привет','Дима')

/*
  Важно помнить: переменные, объявленные в качестве параметров при объявлении функций - являются локальными переменными
*/
// const message = 'Hello'

// function logMessage(message, count) {
//   message = `(((${message})))`

//   for (let i = 0; i < count; i++) {
//     console.log(message)
//   }
// }

// logMessage(message, 4)
// console.log(message)
/*
  Мы фактически передали в качестве аргумента строку "Hello", но при этом, не поменяли исходный message.
  У нас получилась локально объявленная переменная message, и все изменения мы произвели с ней, никак
  не затронув глобальную переменную message.

  Такой код, по хорошему, писать не стоит, так как он может очень сильно запутать!!!!
  Поэтому лучше написать так:
*/
// const globalMessage = 'Hello'

// function logMessage(message, count) {
//   const formatedMessage = `(((${message})))`

//   for (let i = 0; i < count; i++) {
//     console.log(formatedMessage)
//   }
// }

// logMessage(globalMessage, 4)
// console.log(globalMessage)
/*
  Мы изменили название глобальной переменной, чтобы не возникло путаницы.
  Также, переопределять переменную, переданную в качестве параметра функции - это плохая практика.
  Лучше всего создать отдельную переменную "formatedMessage" и изменить её.
*/
/*
  При объявлении функции мы можем указать значение по умолчанию.
  Это нужно, если при вызове функции мы, например, не передали какой-то аргумент в функцию.
  Если мы не передадим аргумент и не укажем значение по умолчанию - то функция может не срабодать,
  так как параметр будет "undefined"
*/
// const globalMessage = 'Hello'

// function logMessage(message, count = 4) {
//   const formatedMessage = `(((${message})))`

//   for (let i = 0; i < count; i++) {
//     console.log(formatedMessage)
//   }
// }

// logMessage(globalMessage)
// console.log(globalMessage)
/*
  Мы не передали при вызове функции аргумент "count", но так как у нас есть значение
  по умолчанию - функция отработала корректно.
  Если мы всё таки укажем аргумент при вызове, то в качестве "count" возьмется именно он.
*/


/*
  С помощью ключевого слова "return" мы возвращаем значение из функции.
*/
function sum(a, b) {
  return a + b
}

const result = sum(5, 12)
console.log(result)
/*
  Код, написанный после "return" не будет исполнен
*/